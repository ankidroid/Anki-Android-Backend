/*
 * Copyright (c) 2020 David Allison <davidallisongithub@gmail.com>
 *
 * This program is free software; you can redistribute it and/or modify it under
 * the terms of the GNU General Public License as published by the Free Software
 * Foundation; either version 3 of the License, or (at your option) any later
 * version.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
 * PARTICULAR PURPOSE. See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along with
 * this program.  If not, see <http://www.gnu.org/licenses/>.
 */

apply plugin: 'java-library'
apply plugin: 'signing'
apply plugin: 'com.vanniktech.maven.publish'

dependencies {
    implementation fileTree(dir: 'libs', include: ['*.jar'])
    // obtaining the OS
    implementation 'org.apache.commons:commons-exec:1.3'
}

jar {
    sourceSets {
        main {
            resources {
                def assetsPath = new File("${project.rootDir}", "rsdroid-testing/assets")
                println "assets path: ${assetsPath.absolutePath}"
                srcDirs assetsPath.absolutePath
            }
        }
    }
}

sourceCompatibility = "1.7"
targetCompatibility = "1.7"

enum Platform {
    LINUX, MACOS, WINDOWS
}

def Platform getCurrentPlatform() {
    def currentOS = org.gradle.internal.os.OperatingSystem.current()
    if (currentOS.isWindows()) return Platform.WINDOWS
    if (currentOS.isMacOsX()) return Platform.MACOS
    if (currentOS.isLinux()) return Platform.LINUX

    throw "Unsuported OS"
}

def getInputDir() {
    def path = "${project.sourceSets.main.java.srcDirs[0]}/../../../../rslib-bridge"
    def canonicalPath = new File(path).getCanonicalPath()
    if (!new File(canonicalPath).exists()) {
        throw new FileNotFoundException("could not find working directory: ${canonicalPath}")
    }
    return canonicalPath
}

def getAssetsDir() {
    return "${project.sourceSets.main.java.srcDirs[0]}/../../../assets";
}

def getTargetDir() {
    return getInputDir() + "/target"
}

def toWindowsCommandLine(String command) {
    def path = getAssetsDir()
    def canonicalAssetsPath = new File(path).getCanonicalPath()
    if (!new File(canonicalAssetsPath).exists()) {
        throw new FileNotFoundException("could not find output path: ${canonicalAssetsPath}")
    }
    return ["bash", "--login", "-c", command]
}

def toCommandLine(Platform targetPlatform) {
    // the --out-dir flag requires -Z unstable-options
    // -Z unstable-options requires a 'nightly' toolchain
    // TODO: Explain how to select the version

    def useCross = System.getenv("NO_CROSS") != "true"
    if (useCross && getCurrentPlatform() == targetPlatform) {
        useCross = false
    }

    def standardArg = "${useCross ? "cross" : "cargo"} build --release --features no-android --verbose"
    def assetsPath = new File("${project.sourceSets.main.java.srcDirs[0]}/../../../assets").getCanonicalPath()

    String assetsSubPath = "/rsdroid-testing/assets"
    File f = new File(project.rootDir, assetsSubPath)
    // As we're running through WSL, we need a Unix path for windows:
    // C:\GitHub\Rust-Test\rsdroid-testing\assets -> /mnt/c/GitHub/Rust-Test/rsdroid-testing/assets
    String path = !org.gradle.internal.os.OperatingSystem.current().isWindows() ? f.absolutePath :
            "/mnt/" + f.absolutePath[0].toLowerCase() + f.absolutePath.substring(1).replace(":\\", "\\").replace("\\", "/")

    println "Outputting to: ${path}"
    def outDir = ""
    System.out.println(assetsPath)
    def mainArg = standardArg + " " + outDir
    if (useCross) {
        mainArg = "DONT_RUSTFMT=1 " + mainArg //FIXME: try to mount $CARGO_HOME/bin and add it to path using cross
    }
    switch (targetPlatform) {
        case Platform.LINUX: return toWindowsCommandLine("CC=\$ANKIDROID_LINUX_CC ${mainArg} --target x86_64-unknown-linux-gnu")
        case Platform.MACOS:
            /// x86_64-apple-darwin14-cc
            return toWindowsCommandLine("CC=\$ANKIDROID_MACOS_CC ${mainArg} --target x86_64-apple-darwin")
        case Platform.WINDOWS: return toWindowsCommandLine("${mainArg} --target x86_64-pc-windows-gnu")
    }
    throw new IllegalStateException(targetPlatform)
}

task preBuildWindows(type: Exec) {
    doFirst {
        logger.lifecycle(toCommandLine(Platform.WINDOWS).join(" "))
    }
    workingDir(getInputDir())
    commandLine(toCommandLine(Platform.WINDOWS))
}

task preBuildMac(type: Exec) {
    doFirst {
        logger.lifecycle(toCommandLine(Platform.MACOS).join(" "))
    }

    if (!org.gradle.internal.os.OperatingSystem.current().isMacOsX()) {
        return

/*        def macCC = System.getenv("ANKIDROID_MACOS_CC")
        println "ANKIDROID_MACOS_CC: ${System.getenv("ANKIDROID_MACOS_CC")}"
        if (macCC == null || macCC == "") {
            throw new IllegalStateException("ANKIDROID_MACOS_CC not set.\n" +
                    "Please install a MacOS toolchain.\n" +
                    "See folder: rsdroid-testing/tools and https://wapl.es/rust/2019/02/17/rust-cross-compile-linux-to-macos.html")
        }*/

    }
    workingDir(getInputDir())
    commandLine(toCommandLine(Platform.MACOS))
}

task preBuildLinux(type: Exec) {
    doFirst {
        logger.lifecycle(toCommandLine(Platform.LINUX).join(" "))
    }
    workingDir(getInputDir())
    commandLine(toCommandLine(Platform.LINUX))
}

task copyLinuxOutput(type: Copy) {
    dependsOn preBuildLinux
    File linuxDir = new File(targetDir, "x86_64-unknown-linux-gnu/release/")
    from linuxDir
    include "*.so"
    into assetsDir
}

task copyMacOutput(type: Copy) {
    dependsOn preBuildMac
    File macosDir = new File(targetDir, "x86_64-apple-darwin/release/")
    from macosDir
    include "*.dylib"
    into assetsDir
}

task copyWindowsOutput(type: Copy) {
    dependsOn preBuildWindows
    File windowsDir = new File(targetDir, "x86_64-pc-windows-gnu/release/")
    from windowsDir
    include "*.dll"
    include "*.dll.a"
    into assetsDir
}


// TODO: check for cargo
// check for targets: x86_64-apple-darwin, x86_64-pc-windows-gnu, TODO: Linux

processResources.dependsOn preBuildWindows
processResources.dependsOn copyWindowsOutput
// To fix: "toolchain 'nightly-x86_64-unknown-linux-gnu' is not installed"
// execute in bash: rustup toolchain install nightly-x86_64-unknown-linux-gnu
// "linker `x86_64-unknown-linux-gnu-gcc` not found"
// sudo ln -s /usr/bin/cc /usr/local/bin/x86_64-unknown-linux-gnu-gcc

// rustup target add x86_64-pc-windows-gnu --toolchain nightly
// brew install mingw-w64 && x86_64-w64-mingw32-gcc -v
processResources.dependsOn preBuildLinux
processResources.dependsOn copyLinuxOutput

if (org.gradle.internal.os.OperatingSystem.current().isMacOsX()) {
    // due to restrictions on downloading the MacOS SDK, we can only build for MacOS on MacOS
    // > Install a reasonable number of copies of the Apple Software on Apple-branded computers
    // https://www.apple.com/legal/sla/docs/xcode.pdf
    processResources.dependsOn preBuildMac
    processResources.dependsOn copyMacOutput
}

signing {
    def hasPrivate = project.hasProperty('SIGNING_PRIVATE_KEY')
    def hasPassword = project.hasProperty('SIGNING_PASSWORD')
    if (hasPrivate && hasPassword) {
        useInMemoryPgpKeys(project.getProperty('SIGNING_PRIVATE_KEY'), project.getProperty('SIGNING_PASSWORD'))
    } else {
        def message = "Publishing to Sonatype will not work - PGP keys not set for publishing"

        def pk = System.getenv("ORG_GRADLE_PROJECT_SIGNING_PRIVATE_KEY")
        def pwd = System.getenv("ORG_GRADLE_PROJECT_SIGNING_PASSWORD")

        logger.warn("$message: ${hasPrivate}, ${hasPassword}, ${pk == null || "" == pk}, ${pwd == null || "" == pwd}")
    }
}